#### 2.1 Typical API Deployment
(+) An API is implemented by application code running on a server; either an application server such as Java Enterprise Edition (Java EE), or a standalone server. 

(+) It is very rare to directly expose such a server to the internet, or even to an internal intranet. Instead, requests to the API will typically pass through one or more additional network services before they reach your API servers

![[Pasted image 20251020165934.png]]

(+) Each request will pass through one or more `Firewall`, which inspect network traffic. A `load balancer` will then route traffic to appropriate services and ensure that one server is not overloaded with lots of request. Finally, a `reverse proxy (or gateway)` is typically placed in front of the application servers to perform computational expensive operation like `handing TLS encryption (known as SSL termination)` and `validate credentials on request` 

(+) `An API gateway` is a specialized reverse proxy that can make different APIs appear as if they are a single API. API gateways can often also take care of some of the aspects of API security discussed in this book, such as authen tication or rate-limiting

(+) `A Web Application firewall (WAF)` inspects traffic at a higher level than a tradi tional firewall and can detect and block many common attacks against HTTP web services

(+) `An intrusion detection system (IDS)` or `Intrusion Prevention System (IPS)`  monitors traffic within your internal networks. When it detects suspicious patterns of activity it can either raise an alert or actively attempt to block the suspicious traffic.

#### 2.2 Elements of API Security
(+) An API by its very nature defines a set of operations that a caller is permitted to use. If you don’t want a user to perform some operation, then simply exclude it from the API. So why do we need to care about API security at all?

==> First, the same API may be accessible to users with `distinct levels of authority`; for example, with some operations allowed for only administrators or other users with a special role. Without appropriate access controls, any user can perform any action, which is likely to be undesirable.

==> Second, while each individual operation in an API may be secure on its own, com binations of operations might not be. For example, a banking API might offer separate withdrawal and deposit operations, which individually check that limits are not exceeded. But the deposit operation has no way to know if the money being deposited has come from a real account.

==> Last, there may be security vulnerabilities due to the implementation of the API. For example, failing to check the size of inputs to your API may allow an attacker to bring down your server using DoS.

##### 2.2.1 Assets
(+) For most APIs, the assets will consist of information, such as customer names and addresses, credit card information, and the contents of databases.

==> In short, anything connected with your system that has value to somebody should be considered an asset. Put another way, if anybody would suffer real or perceived harm if some part of the system were compromised, that part should be considered an asset to be protected

##### 2.2.2 Security goals
(+) Security goals are used to define what security actually means for the protection of your assets. Security goals can be viewed as non-functional requirements (NFRs) and considered alongside other NFRs such as performance or reliability goals.

(+) There is no single correct way to break down a security goal into specific require ments, and so the process is always one of iteration and refinement as the constraints become clearer over time

![[Pasted image 20251020170749.png]]

##### 2.2.3 Environments and threat models
(+) A good definition of API security must also consider the environment in which your API is to operate and the potential threats that will exist in that environment.

(+) A `threat` is simply any way that a security goal might be violated with respect to one or more of your assets

(+) The set of threats that you consider relevant to your API is known as your `threat model`, and the process of identifying them is known as threat modeling. Threat modeling is the process of systematically identifying threats to a software system so that they can be recorded, tracked, and mitigated.

***"Plans are worthless, but planning is everything"***

![[Pasted image 20251020171058.png]]

#### 2.3 Security Mechanisms
(+) Threats can be countered by applying security mechanisms that ensure that particular security goals are met:
1. `Encryption` ensures that data can’t be read by unauthorized parties, either when it is being transmitted from the API to a client or at rest in a database or filesys tem. Modern encryption also ensures that data can’t be modified by an attacker. 
2. `Authentication` is the process of ensuring that your users and clients are who they say they are.  
3. `Access control` (also known as authorization) is the process of ensuring that every request made to your API is appropriately authorized.  
4. `Audit logging` is used to ensure that all operations are recorded to allow account ability and proper monitoring of the API.  
5. `Rate-limiting` is used to prevent any one user (or group of users) using all of the resources and preventing access for legitimate users.
![[Pasted image 20251020171236.png]]

---
# Lab section:

#### A. Injection attacks
```java
public JSONObject createSpace(Request request, Response response) throws SQLException {
    var json = new JSONObject(request.body());
    var spaceName = json.getString("name");
    var owner = json.getString("owner");

    return database.withTransaction(tx -> {
        var spaceId = database.findUniqueLong("SELECT NEXT VALUE FOR space_id_seq;");

        // WARNING: this next line of code contains a security vulnerability!
        database.updateUnique(
            "INSERT INTO spaces(space_id, name, owner) " +
            "VALUES(" + spaceId + ", '" + spaceName + "', '" + owner + "');"
        );

        response.status(201);
        response.header("Location", "/spaces/" + spaceId);

        return new JSONObject()
            .put("name", spaceName)
            .put("uri", "/spaces/" + spaceId);
    });
}
```

(+) Unfortunately, the code you’ve just written has a serious security vulnerability, known as a `SQL injection attack`. Injection a>ttacks are one of the most widespread and most serious vulnerabilities in any software application

> [!info] Definition of Injection attack
> An injection attack occurs when`unvalidated user input is included directly` in a dynamic command or query that is executed by the application, allowing an attacker to control the code that is executed

(+) The Natter createSpace operation is vulnerable to a SQL injection attack because it constructs the command to create the new social space by concatenating user input directly into a string. 
==> The result is then sent to the database where it will be interpreted as a SQL command.

##### A1. Detailed explanation of the vulnerability

###### Intended SQL behavior
(+) The vulnerable Java code build this SQL string:

```java
"INSERT INTO spaces(space_id, name, owner) " +
"VALUES(" + spaceId + ", '" + spaceName + "', '" + owner + "');"
```

(+) If the user sends: 
``` bash
curl -i -d '{"name": "testspace", "owner": "demo"}'
http://localhost:4567/spaces
```

(+) The application will construct a valid SQL command:
```sql
INSERT INTO spaces(space_id, name, owner)
VALUES(4, 'testspace', 'demo');
```

==> The database will executes it, and one table row is inserted.

###### The problem: user input becomes SQL code
(+) A malicious request looks like:
``` bash
curl -i -d "{\"name\": \"test'space\", \"owner\": \"demo\"}" http://localhost:4567/spaces
```

(+) Inside JSON, keys and string values **must be double-quoted**, like `"name"` and `"demo"`.   But because you already wrapped the entire `-d` argument in double quotes, you have to escape those inner double quotes, or else the shell will break the string early.

So: `"{\"name\": ... }"`
means:
- `\"` → becomes just `"` inside the final string
- the outer quotes `"` → mark the shell string boundaries

(+) After concatenation, the server construct:

```sql
INSERT INTO spaces(space_id, name, owner)
VALUES(4, 'test'space', 'demo');
```

==> Resulted in an error

(+) Another malicious request might look like:
```bash
curl -i -d "{\"name\": \"test\", \"owner\": \"'); DROP TABLE spaces; --\"}" http://localhost:4567/spaces
```

(+) In the malicious request, `"name" will be "test"`, but `"owner" will be "'); DROP TABLE spaces; --"`. Making our SQL becomes:
```sql
INSERT INTO spaces(space_id, name, owner)
VALUES(9, 'test', ''); DROP TABLE spaces; --');
```

##### A2. Preventing Injection Attacks
(+) The best approach is to ensure that user input is always clearly `separated from dynamic code` by using APIs that support prepared statements.

![[Pasted image 20251020180723.png]]

(+) The prepared statement for our code would looks like

```java
// Vulnerable (string concatenation) — do not use
/*
database.updateUnique(
    "INSERT INTO spaces(space_id, name, owner) " +
    "VALUES(" + spaceId + ", '" + spaceName + "', '" + owner + "');"
);
*/

// Safe (parameterized query)
database.updateUnique(
    "INSERT INTO spaces(space_id, name, owner) VALUES(?, ?, ?);",
    spaceId,
    spaceName,
    owner
);
```

(+) While prepared statements should be your number one defense against SQL injection attacks, another aspect of the attack worth mentioning is that the `database user didn’t need to have permissions to delete tables in the first place`.

> [!info] Principle of Least Authority
> The principle of least authority (POLA), also known as the principle of least privilege, says that all users and processes in a system should be given only those permissions that they need to do their job—no more, and no less.

(+) A safer alternative is to create a new user and only grant it exactly the permissions that it needs. To do this, we can use the SQL standard CREATE USER and GRANT commands.

```sql 
CREATE USER natter_api_user PASSWORD 'password'; 
GRANT SELECT, INSERT ON spaces, messages TO natter_api_user;
```

![[Pasted image 20251020182456.png]]

#### B. Input validation
(+) Security flaws often occur when an attacker can submit inputs that violate your assumptions about how the code should operate. For example, you might assume that an input can never be more than a certain size. If you’re using a language like C or C++ that lacks memory safety, then failing to check this assumption can lead to a seri ous class of attacks known as buffer overflow attacks.

>[!info] Buffer overflow
>A buffer overflow or buffer overrun occurs when an attacker can sup ply input that exceeds the size of the memory region allocated to hold that input. If the program, or the language runtime, fails to check this case then the attacker may be able to overwrite adjacent memory.

(+) In the Natter API code, the input to the API call is presented as structured JSON. As Java is a memory-safe language, you don’t need to worry too much about buffer over flow attacks. You’re also using a well-tested and mature JSON library to parse the input, which eliminates a lot of problems that can occur

(+) Although the API is using a safe JSON parser, it’s still trusting the input in other regards. For example, it doesn’t check whether the supplied username is less than the 30-character maximum configured in the database schema.

![[Pasted image 20251020182949.png]]
(+) But you shouldn’t rely on the database to catch all errors. A database is a valuable asset that your API should be protecting from invalid requests. Sending requests to the database that contain basic errors just ties up resources that you would rather use pro cessing genuine requests.

>[!info] Principle of input validation
>Always define acceptable inputs rather than unacceptable ones when val idating untrusted input. An allow list describes exactly which inputs are con sidered valid and rejects anything else.1 A blocklist (or deny list), on the other hand, tries to describe which inputs are invalid and accepts anything else.

(+) Regular expressions are a useful tool for input validation, because they can succinctly express complex constraints on the input. In this case, the regular expression ensures that the username consists only of alphanumeric characters, doesn’t start with a num ber, and is between 2 and 30 characters in length

>[!info] ReDoS Attacks
>A regular expression denial of service (or ReDoS) attack occurs when a regular expres sion can be forced to take a very long time to match a carefully chosen input string. This can happen if the regular expression implementation can be forced to back-track many times to consider different possible ways the expression might match.

###### Producing safe output
(+) In addition to validating all inputs, an API should also take care to ensure that the out puts it produces are well-formed and cannot be abused

```
HTTP/1.1 400 Bad Request 
Date: Fri, 01 Feb 2019 15:21:16 GMT 
Content-Type: text/html;charset=utf-8 
Transfer-Encoding: chunked 
Server: Jetty(9.4.8.v20171121) 

{"error": "java.lang.IllegalArgumentException: invalid username: a really long username that is more than 30 characters long"}
```

(+) There are 3 separate problems with this output
1. It includes details of the exact Java exception that was thrown. Although not a vulnerability by itself, these kinds of details in outputs help a potential attacker to learn what technologies are being used to power an API.
2. It echoes back the erroneous input that the user supplied in the response and doesn’t do a good job of escaping it. When the API client might be a web browser, this can result in a vulnerability known as reflected `cross-site scripting (XSS)`
3. The Content-Type header in the response is set to text/html rather than the expected application/json. Combined with the previous issue, this increases the chance that an XSS attack could be pulled off against a web browser client.

#### C. Cross-site Scripting
(+) Cross-site scripting, or XSS, is a common vulnerability affecting web applications, in which an attacker can `cause a script to execute in the context of another site`. In a persistent XSS, the script is stored in data on the server and then executed whenever a user accesses that data through the web application

(+) A `reflected XSS` occurs when a maliciously crafted input to a request causes the script to be included (reflected) in the response to that request. Reflected XSS is slightly harder to exploit because a victim has to be tricked into visiting a website under the attacker’s control to trigger the attack.

(+) A third type of XSS, known as `DOM-based XSS`, attacks JavaScript code that dynamically creates HTML in the browser

==> These can be devastating to the security of a web application, allowing an attacker to potentially steal session cookies and other credentials, and to read and alter data in that session. To appreciate why XSS is such a risk, you need to understand that the security model of web browsers is based on the same-origin policy (SOP). 

==> Scripts executing within the same origin (or same site) as a web page are, by default, able to read cookies set by that website, examine HTML elements created by that site, make network requests to that site, and so on, although scripts from other origins are blocked from doing those things

(+) A successful XSS allows an attacker to execute their script as if it came from the target origin, so the malicious script gets to do all the same things that the genuine scripts from that origin can do. If I can successfully exploit an XSS vulnerability on facebook.com, for example, my script could potentially read and alter your Facebook posts or steal your private messages.

##### C1. Exploiting XSS Attacks
(+) To understand the XSS attack, let’s try to exploit it. Before you can do so, you may need to add a special header to your response to turn off built-in protections in some browsers that will detect and prevent reflected XSS attacks.

```java
afterAfter((request, response) -> { 
	response.header("X-XSS-Protection", "0"); 
});
```

(+) The X-XSS-Protection header is usually used to ensure browser protections are turned on, but in this case, you’ll turn them off temporarily to allow the bug to be exploited.

![[Pasted image 20251020192441.png]]

![[Pasted image 20251020192647.png]]

1. When the form is submitted, the browser sends a POST request to http://3.107.8.77:8080/spaces with a Content-Type header of text/plain and the hidden form field as the value When the browser submits the form, it takes each form element and submits them as name=value pairs. The <, > and ' HTML entities are replaced with the literal values <, >, and ' respectively. If the form used `text/plain` (or the browser/attacker forced that form of submission), the browser will replace HTML entities like `&lt;`, `&gt;`, `&apos;` with their literal characters `<`, `>`, `'` when assembling the payload. That means the `<script>...</script>`


```json
{"x":"=","name":"x","owner":"<script>alert('XSS!');</script>"}
```

2. **The server/API parses the incoming body.** The API sees the assembled text and can parse it as JSON (or treat it as JSON-looking input). It finds an `owner` value that contains `<script>…</script>`.

3. **The server validates and rejects the input**, producing an error message that _includes the raw user input_ (the `owner` value) in the error text:
```json
{"error":"java.lang.IllegalArgumentException: 
invalid username: <script>alert('XSS!');</script>"}
```

4. **The response is sent as `text/html` (the default).** The browser receives that error and — because the response is `text/html` — treats the payload as HTML. The `<script>` in the error is executed by the browser, causing the XSS popup.

###### Why the `{"x":"=",...}` weirdness?
(+) The attacker is abusing how forms are serialized: by choosing input _names_ and _values_ that, when concatenated by the browser, form syntactically valid JSON. The hidden field is used to hide or place an extra `=` or other character so the assembled payload looks exactly like valid JSON. In other words: instead of sending a JSON body directly, they piggyback JSON-like content in ordinary form fields so it reaches the server as valid JSON text.

##### C1. How to prevent XSS
(+) Be strict in what you accept. If your API consumes JSON input, then require that all requests include a Content-Type header set to application/json. This prevents the form submission tricks that you used in this example, as a HTML form cannot submit application/json content.
(+) Ensure all outputs are well-formed using a proper JSON library rather than by concatenating strings.
(+) Produce correct Content-Type headers on all your API’s responses, and never assume the defaults are sensible. Check error responses in particular, as these are often configured to produce HTML by default.

![[Pasted image 20251020193628.png]]
![[Pasted image 20251020193637.png]]

(+) Modern web browsers also support the Content-Security-Policy header (CSP) that can be used to reduce the scope for XSS attacks by restricting where scripts can be loaded from and what they can do. CSP is a valuable defense against XSS in a web application

![[Pasted image 20251020193715.png]]

##### C2. Implementing the protection
(+) First, add a before() filter that runs before each request and checks that any POST body submitted to the API has a correct Content-Type header of application/ json

(+) Secondly, you’ll add a filter that runs after all requests to add our recommended security headers to the response. You’ll add this as a Spark afterAfter() filter, which ensures that the headers will get added to error responses as well as normal response